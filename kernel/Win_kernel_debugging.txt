WinDbg kernel debugging - 


issues with nt symbols. try .reload, or !sym noisy     then .reload to see whats happening

Setting up for kernel debugging - 
  msconfig.exe for gui -> Boot -> Adv. Opts. -> check Debug
  or
  bcdedit.exe -debug on (elevated cmd)
  Then reboot
  
Launch WinDbg elevated -> File | Kernel Debug... | Local     (local kernel debugging), remote different.

Remote debugging with vmware OS - 
  bcdedit /dbgsettings serial debugport:n baudrate:115200
  where n is the number of a COM port on the virtual machine
  or
  via gui, can do msconfig Boot->Adv. Opts. -> debug port
  or
  bcdedit /dbgsettings net hostip:<ip> port:<port> [key:<key>]    (random key if not provided)

VMWare, add serial port:
  Use named pipe: \\.\pipe\com_1
  This end is the server

Launch windbg elevated with this command:
  windbg.exe -y "srv*d:\symbols*https://msdl.microsoft.com/download/symbols" -k com:pipe,port=\\.\pipe\com_1,resets=0,reconnect
  or
  select network debugging and set same port and key as above
  
  
LiveKD from sysinternals allows kernel debugging without configuring the machine in debug mode.  Installs a kernel driver.  Copy LiveKd.exe to dir of WinDbg
  launch with livekd -w
  syncronization issues so it may not be the best option but does work. requires "refresh" by restarting livekd to get it sync'd
  

Kernel Exploration:
  32 bit
    2GB User Process Space -> 00000000 -> 80000000
    2GB System Space -> 80000000 -> FFFFFFFF
  
  64 bit
    128 TB User Process Space ->  000000000000 -> 7FFFFFFFFFFF
    Unmapped
    128 TB System Space -> FFFF80000000000 -> FFFFFFFFFFFFFFF
    
  Windows 8 (x64) and earlier support 8 TB user / kernel address space
  
  Processes:
    Kernel mode:
      Managed by EPROCESS -> execute process object
      KPROCESS -> kernel process object
        First member of EPROCESS is named Pcb (Process Control Block)
      All processes doubly linked list
        LIST_ENTRY member is ActiveProcessLinks
        Root is PsActiveProcessHead kernel variable
    User mode:
      PEB (Process Environment Block)
      
    ? nt!PsActiveProcessHead -> give me address of head of linked list for processes.
    dt nt!_LIST_ENTRY <address from prev command>    ->  display type of the list_entry for process
    Flink should give you the first process in the list.
    
    The EPROCESS object contains ActiveProcessLinks at offset +0x2f0, so in order to view the first process, use Flink address - offset for ActiveProcessLinks
    !process <addr>-2f0 0
    Gives System process (first in list)
    
    easy view processes:
      dx Debugger.Sessions[0].Processes
      dx -r2 @$cursession.Processes  (recursive 2 levels)
      
      c# language partly allowed in windbg.
        dx Debugger.Sessions[0].Processes.Where(p => p.Id < 100).OrderBy(p => p.Name)
    
  Modules:
  
  Jobs:
    Jobs manage a set of one or more processes
    Once process assigned to job, it cannot get out
    Job imposes limits on its processes, provides accounting information
    
    Kernel manages it in the EJOB structure
    
    View job info:
      !job <job value>
      !job <job value> 2 -> lists processes that are part of this job
      !job <job value> 4 -> lists all child jobs of this job
      !joblist  -> lists out all the jobs on the system
      dt nt!_ejob <job value>   -> view the ejob structure
    
    Read into Silos (in ejob)
    
  Threads:
  
  Kernel Modules:
  
  Objects and Handles:
    Objects are runtime instances of static structures ->  process, mutex, event, desktop, file
    Objects reside in system memory space, kernel code can obtain direct pointer to an object
    User mode code can only obtain a handle to an object -> shields user code from directly accessing an object
    All objects are reference counted
    
    Object Structure: (system explorer from sysinternals is a good tool to look at this)
      Object manager layer: (WinObj from sysinternals is a good tool for this as well)
        Object Name, Object Directory, Security Descriptor, Open Handle Count, Open Handle List, Pointer Count, Object Type -> Type Object: Type Name, Synchronizable?, Pageable?, Object Methods
        
      Executive object layer:
        Kernel Object
  
    View object info:
      !object <obj value>
      dt nt!_object_type <type value from !object>
      dt nt!_object_header <object header value from !object>
        contains the security descriptor:
          !sd <security descriptor value>   -> the sd val needs to have lower 4 bits zero'd out to work (last digit to 0)
          contains Dacls
      !object \Sessions\<sess_num>\BaseNamedObjects -> will list all objects in the specified session
      
     Handles:
      View handle info:
        Switch to the process with !process 0n2884 0   0n2884 is the PID 2884
        Then use .process /p <process value>; !handle <handle_num>
        !handle lists all the handles in the current process.
        if its a directory object, then it recursively lists them out
        
  Drivers and Devices:
  
  Kernel Mode Breakpoints:
  
  Debugging Driver with Source:
  
  Kernel Dump Files:
  
