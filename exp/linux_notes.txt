exploit closing without accepting input for the shell that should have popped?   (cat ./input.txt; cat) | ./vulnerable


check libraries in use:
  ldd [binary_name]
  or in gdb:  
    vmmap

list all functions from my system's libc version:
  nm -D /lib$(uname -m)-linux-gnu/libc-*.so | grep -vw U | grep -v "_" | cut -d " " -f3
  
check offset of function from libc base (libc on my system)
  readelf -s /lib/i386-linux-gnu/libc.so.6 | grep "system"
  
compiling for exploit practice, 
  -z execstack, turns off NX
  -fno-stack-protector, turns off canary
  -fstack-protector-all, turns on canary
  
  turn off ASLR:
    echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
    echo 0 > /proc/sys/kernel/randomize_va_space
    sysctl -p (apply changes)   0 = no aslr, 1 = stack, virtual dynamic shared object page, and shared memory regions are randomized, 2 = setting 1 + data segments are randomized

local exploitation only, if you need a /bin/sh string in memory.. just export an env variable with the string /bin/sh..
    
gdb-peda helpful commands:
  pattern create <length> <out_file>
  
  run < input_file.txt (for user input)
  
  pattern offset <val_in_buffer>
  
  find /bin  (search for string /bin/bash)
  
  vmmap libc (to check address space of libc)
    and choose the "x" perm addr space since you'll be wanting to execute a function
  
  enable ASLR while debugging:
    set disable-randomization off
    run binary and check vmmap libc each run to make sure address is being randomized
  
  debugging changing eip just to see what happens at an address:
    set $eip=0x<addr>
  
  set an integer value at an address:
    set {int}0x<addr> = 0x<value>


Bypassing ASLR:
  Older kernels:
    attacking entropy.. the randomization only has 0xFF different options, which means each run has a 1/256 possibility of being the right address..
    Just run the exploit with a hardcoded address in the randomization range and it will eventually land (hopefully with few tries as the 1/256 chances are fairly promising)
  
Stack Cookies:
  Other names for this protection are: stack canary, stack protector, stack guard, or SSP
  on x86, 4 byte value pushed to stack whenever a function is entered. Once the function ends and stack frame is cleared, stack cookie is checked and verified. if different, __stack_chk_fail termination.
  
  Stack cookies may be the protection blocking the overflow if errors come up with things like: "Stack smashing detected" or __stack_chk_fail type functions
  
  Types:
    Random Canary:
      4 byte value generated by RNG (/dev/random)
    Random XOR Canary:
      random canary is XOR'd with stored control data
    Null Canary:
      contains 0x00000000 so that user can't put nulls to the stack (lol)
    Terminator Canary:
      set to a combo of string terminators (0x00, 0xff, 0x0a, 0x0d, etc)
  
  Things to answer to make bypass easier:
    What is the value? Does it change?
    What type?
    What function is vulnerable and what chars are accepted?
    Can the exploit fire before return?
    Remote or local? Low or high entropy of canary value for potential brute force?
  
  Most likely want to use an info leak of the value with a ret2write or if its a format string vuln.
  
RELRO:
  <RELRO NOTES>
  
  If RPATH attribute is enabled, a path is specified where a library can be included.  It's hardcoded so it could be abused by placing a library in that path and having it load my own functions that replace the proper one. 
  
  
easy shells -> system(), exec*   (execl, execle, exelp, execv, execve, etc..)

options for overflows and ret2 style attacks can include ret2strcpy, ret2read, ret2main. 

stack during basic ret2libc overflow (no aslr, NX enabled).  FUNC_ADDR(EIP), RET_ADDR_AFTER_FUNC, [ARGS]
