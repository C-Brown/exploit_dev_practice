This time we can see calls to malloc and free so it must be a heap exploit.

The chunk formatting is

<prev> <next> <size> <data>

Throwing random input to see if we can overflow some chunks, i see that we can overflow the 2nd chunk's prev, next, and size fields when inputting the username. 
I can also overflow to overwrite the prev, next, and size fields of the top chunk.   So we can get a write somewhere by using an unlink exploit on the free calls.

I can just overwrite the address of the 2nd free call with a target address to jump to (our chunk where we can write some shellcode to jump to unlock_door)

for username, i'll use 16 bytes to fill up to the next chunk's prev value. I'll make the 2nd chunk's prev addr be 2434 (the address of the next chunk)
The 2nd chunk's next addr will be 46ac, the address of the target write (the 2nd free call). 
The 2nd chunk's size will still be 2100.

Since the 2nd chunk is free'd first, this will make the write.  It will write the address of our next chunk into the target address. So I will effectively make it "call 2434" which is where our top chunk is. I'll make that chunk have shellcode to execute. 

For password, I'll use another 16 bytes for filler up to the top chunk's prev value.
The prev value will contain 023c which equates to "jmp $+0x6".   This is there because we need to preserve the formatting of the top chunk's next and size fields.  This jumps to the top chunk data (which I can also control and fill with some more shellcode)
The next value will contain 6445 (just a value i placed for no reason)
The size field will contain 9c1f because that's what it was by default when I didn't overflow
Then the top chunk data will begin with my own bytes b0126445 which equates to "call #0x4564"  0x4564 is the unlock_door function address. 

When the first free is called on the 2nd chunk, we overwrite the 2nd free call with the address of the top chunk, so execution is passed to the top chunk's address, which reads to jump forward to the "call unlock_door".

username:
414141414141414141414141414141413424ac462100

password:
41414141414141414141414141414141023c64459c1fb0126445



Better solution:


Tried again by just overwriting the 2nd call and making it overwrite and jump to unlock_door using only the username overwrite.  

Turns out that the overwrite values are basically nops for what we want to execute in unlock_door.  So I can set the target address to be 455e which is 6 bytes before the beginning of unlock_door.  So we overwrite 6 bytes, jump to it, they nop, then unlock_door executes. 

username:
414141414141414141414141414141415e45ac46
password:
(leave this blank)

41414141414141414141414141414141    - filler
5e45 - overwrite & execute
ac46 - target write address


Another alternate solution:


username: 
023c64459c1fb01264454141414141410e249a43
password:
(leave this blank)

overwrite the return address of login on the stack with my buffer's address and fill the buffer with shellcode. 6 bytes of padding before the call due to the chunk metadata overwrites.
