WinDbg kernel debugging - 


issues with nt symbols. try .reload, or !sym noisy     then .reload to see whats happening
specific dll to reload symbols ->   .reload / ntdll.dll     force reload
.reload /user -> reload user mode symbols
hex to decimal ->    ? 3e8    outputs 1000

Install driver ->
  elevated cmd
  sc create <whatever_name_you_want> type= kernel binPath= <path to .sys file>
    SUCCESS means installed, but still have to load
  sc start <whatever_name_you_wanted_above>
    STATE RUNNING means loaded
  sc stop <whatever_name_you_wanted_above>

Setting up for kernel debugging - 
  msconfig.exe for gui -> Boot -> Adv. Opts. -> check Debug
  or
  bcdedit.exe -debug on (elevated cmd)
  Then reboot
  
Launch WinDbg elevated -> File | Kernel Debug... | Local     (local kernel debugging), remote different.

Remote debugging with vmware OS - 
  bcdedit /dbgsettings serial debugport:n baudrate:115200
  where n is the number of a COM port on the virtual machine
  or
  via gui, can do msconfig Boot->Adv. Opts. -> debug port
  or
  bcdedit /dbgsettings net hostip:<ip> port:<port> [key:<key>]    (random key if not provided)

VMWare, add serial port:
  Use named pipe: \\.\pipe\com_1
  This end is the server

Launch windbg elevated with this command:
  windbg.exe -y "srv*d:\symbols*https://msdl.microsoft.com/download/symbols" -k com:pipe,port=\\.\pipe\com_1,resets=0,reconnect
  or
  select network debugging and set same port and key as above
  
  
LiveKD from sysinternals allows kernel debugging without configuring the machine in debug mode.  Installs a kernel driver.  Copy LiveKd.exe to dir of WinDbg
  launch with livekd -w
  syncronization issues so it may not be the best option but does work. requires "refresh" by restarting livekd to get it sync'd
  

Kernel Exploration:
  32 bit
    2GB User Process Space -> 00000000 -> 80000000
    2GB System Space -> 80000000 -> FFFFFFFF
  
  64 bit
    128 TB User Process Space ->  000000000000 -> 7FFFFFFFFFFF
    Unmapped
    128 TB System Space -> FFFF80000000000 -> FFFFFFFFFFFFFFF
    
  Windows 8 (x64) and earlier support 8 TB user / kernel address space
  
  Processes:
    Kernel mode:
      Managed by EPROCESS -> execute process object
      KPROCESS -> kernel process object
        First member of EPROCESS is named Pcb (Process Control Block)
      All processes doubly linked list
        LIST_ENTRY member is ActiveProcessLinks
        Root is PsActiveProcessHead kernel variable
    User mode:
      PEB (Process Environment Block)
      
    ? nt!PsActiveProcessHead -> give me address of head of linked list for processes.
    dt nt!_LIST_ENTRY <address from prev command>    ->  display type of the list_entry for process
    Flink should give you the first process in the list.
    
    The EPROCESS object contains ActiveProcessLinks at offset +0x2f0, so in order to view the first process, use Flink address - offset for ActiveProcessLinks
    !process <addr>-2f0 0
    Gives System process (first in list)
    
    easy view processes:
      dx Debugger.Sessions[0].Processes
      dx -r2 @$cursession.Processes  (recursive 2 levels)
      
      c# language partly allowed in windbg.
        dx Debugger.Sessions[0].Processes.Where(p => p.Id < 100).OrderBy(p => p.Name)
    
  Modules:
  
  Jobs:
    Jobs manage a set of one or more processes
    Once process assigned to job, it cannot get out
    Job imposes limits on its processes, provides accounting information
    
    Kernel manages it in the EJOB structure
    
    View job info:
      !job <job value>
      !job <job value> 2 -> lists processes that are part of this job
      !job <job value> 4 -> lists all child jobs of this job
      !joblist  -> lists out all the jobs on the system
      dt nt!_ejob <job value>   -> view the ejob structure
    
    Read into Silos (in ejob)
    
  Threads:
  
  Kernel Modules:
  
  Objects and Handles:
    Objects are runtime instances of static structures ->  process, mutex, event, desktop, file
    Objects reside in system memory space, kernel code can obtain direct pointer to an object
    User mode code can only obtain a handle to an object -> shields user code from directly accessing an object
    All objects are reference counted
    
    Object Structure: (system explorer from sysinternals is a good tool to look at this)
      Object manager layer: (WinObj from sysinternals is a good tool for this as well)
        Object Name, Object Directory, Security Descriptor, Open Handle Count, Open Handle List, Pointer Count, Object Type -> Type Object: Type Name, Synchronizable?, Pageable?, Object Methods
        
      Executive object layer:
        Kernel Object
  
    View object info:
      !object <obj value>
      dt nt!_object_type <type value from !object>
      dt nt!_object_header <object header value from !object>
        contains the security descriptor:
          !sd <security descriptor value>   -> the sd val needs to have lower 4 bits zero'd out to work (last digit to 0)
          contains Dacls
      !object \Sessions\<sess_num>\BaseNamedObjects -> will list all objects in the specified session
      
     Handles:
      View handle info:
        Switch to the process with !process 0n2884 0   0n2884 is the PID 2884
        Then use .process /p <process value>; !handle <handle_num>
        !handle lists all the handles in the current process.
        if its a directory object, then it recursively lists them out
        
  Drivers and Devices:
    Drivers -> loadable kernel modules
      Plug n play, file system, file system (mini) filters, "software", etc.
    Driver object manages the basic properties of a driver
      DRIVER_OBJECT struct
    
    Device Objects are created by drivers as needed to represent hardware or software entities 
      DEVICE_OBJECT struct
    Device objects are maintained in a linked list from the driver object
    
    I/O Request Packet (IRP)
      Struct (IRP) representing some request
        ReadFile -> eventually translated to IRP that is sent to the necessary driver
        Contains all details needed to handle the request (codes, buffers, sizes, etc.)
        Accompanied by set of structs of type IO_STACK_LOCATION
          Number of structs is the numer of the devices in this Device Node
          Complements the data in the IRP
      
      !irp <value>    -> can use something like !irp @rdx if rdx contains the address
        shows the thread and necessary info of the IRP
      dt nt!_IRP @rdx   -> real struct view which contains the StackCount for IO_STACK_LOCATIONs 
      
      Locating IO_STACK_LOCATION:
        dt nt!_IRP -v,   shows size of struct
        dt nt!_IO_STACK_LOCATION (@rdx+0xd0)   0xd0 is the struct size
          in parameters union, includes parameters of the request,   use sub struct DeviceIoControl to view args
          !ioctldecode <value from !irp command at "Args: ">
    
    View Driver object info:
      !drvobj <value or path>    example:   !drvobj \Driver\Beep f
        This contains the actual object value to use:   dt nt!_driver_object <value>    to view the real struct
        Shows list of device objects created by driver
        List of dispatch routines (IRP) function pointers with internal kernal function with info showing what is supported or what function is called based on IRP.
        
    View Device object info:
      !devobj <value>
  
  
  Kernel Mode Breakpoints:
    Using driver object info from above (Beep)
    bp <function name>      ->  bp Beep!BeepOpen
    bp Beep!BeepDeviceControl
    
    bl to list breakpoints
    
    k for stack backtrace with lots of info on how the call is passed from user mode to kernel mode, very useful for learning.
    
    bd * -> disable bp's (not delete)
    
    .reload /user  (to reload symbols for user mode)
    
    set breakpoint in process (in notepad example):
      !process 0 0 notepad.exe
      bp /p <process value> nt!ntwritefile
      
      !process -1 0     <shows current process>
    
    Breaking on driver that isn't loaded yet:
      use unresolved bp syntax:
        bu <name>   ->  example:    bu ThreadBoost!DriverEntry
  
  Debugging Driver with Source:
    On break in the call stack, if source is available, click file name and it will pull up a view of the source for the function from the call stack
    Same as usual code debugging when you ahve access to the source code.
  
  Kernel Dump Files:
    BSOD -> configured with debugger means we can debug before blue screen hits
      bugcheck, stop error, etc all mean BSOD
    Unhandled exception in kernel mode leads to BSOD
    
    If debugger not connected at time of BSOD, writes crash dump info to file which can be opened with WinDbg. Cannot set bp's or step forward, it's just a snapshot.
    
    Debugging tools for windows docs help for specific stop codes
    
    Open dump file with WinDbg
    !analyze -v to get basic crash info
      if hung dump, use !analyze -v -hang
    simple cases typically have issue listed on call stack
    
    Useful commands:
      !process (view processes)
      !running -t (running threads on all processes)
      !stacks (view thread states and stacks)
    
    Control panel, system, adv. system settings, startup and recovery,  System failure check Write an event to the system log
      Write debugging info:
        small memory dump -> small with useful info but typically not enough info
        kernel memory dump -> generates dump with all memory in kernel space, nothing to do with user space since bsod is kernel related
        Automatic memory dump -> change paging file to hold the kernel memory dump so there is no lost dump file
        Complete memory dump -> all memory in kernel and user space, very large.. size of RAM + extra overhead for other info. 
        Active memory dump -> only takes used pages of physical memory and dumps them to dump file for both kernel and user mode.  including guest virtual machines.
    
    Sometimes might need to give full control of dmp file to everyone in VMs, hyper-v issue? 
    
    nt!KeBugCheckEx is the function that actually calls the Blue Screen
    
    Drop and drop the dmp file on to debugger to load it. 
    F1 for documentation to look up BSOD code info:
      Contents -> Bug Checks -> Bug Check Code Reference
    
    !process -1 0 to view current process
    
    
