exploit closing without accepting input for the shell that should have popped?   (cat ./input.txt; cat) | ./vulnerable


check libraries in use:
  ldd [binary_name]
  or in gdb:  
    vmmap

list all functions from my system's libc version:
  nm -D /lib$(uname -m)-linux-gnu/libc-*.so | grep -vw U | grep -v "_" | cut -d " " -f3
  
check offset of function from libc base (libc on my system)
  readelf -s /lib/i386-linux-gnu/libc.so.6 | grep "system"
  
compiling for exploit practice, 
  -z execstack, turns off NX
  -fno-stack-protector, turns off canary
  
  turn off ASLR:
    echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
    echo 0 > /proc/sys/kernel/randomize_va_space
    sysctl -p (apply changes)   0 = no aslr, 1 = stack, virtual dynamic shared object page, and shared memory regions are randomized, 2 = setting 1 + data segments are randomized

local exploitation only, if you need a /bin/sh string in memory.. just export an env variable with the string /bin/sh..
    
gdb-peda helpful commands:
  pattern create <length> <out_file>
  
  run < input_file.txt (for user input)
  
  pattern offset <val_in_buffer>
  
  find /bin  (search for string /bin/bash)
  
  vmmap libc (to check address space of libc)
    and choose the "x" perm addr space since you'll be wanting to execute a function
  
  
  
  
easy shells -> system(), exec*   (execl, execle, exelp, execv, execve, etc..)

options for overflows and ret2 style attacks can include ret2strcpy, ret2read, ret2main. 

stack during basic ret2libc overflow (no aslr, NX enabled).  FUNC_ADDR(EIP), RET_ADDR_AFTER_FUNC, [ARGS]
