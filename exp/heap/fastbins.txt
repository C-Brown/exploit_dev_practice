fastbins double free -
  malloc free() sets up lists of free'd chunks based on size for recycled use (faster access)
  these free lists are called fastbins (or buckets)
  singly linked non circular list, each holds free chunks of the specified size.  
  
  a = malloc(1) allocates a chunk of size 0x20
  free(a) - free's the allocated chunk and puts it in fastbins for recycled use on the next allocation of a chunk with 0x20 size
  
 at this point, fastbins shows as this 
  0x20: <addr_of_a> <- 0x0      (linked list) 
  0x30:
  0x40: 
  0x50: 
  0x60: 
  0x70: 
  0x80: 
  
  
  Arenas - 
    Structs where malloc keeps all of it's non inline metadata. Mostly the heads of each of the fastbins. 
    An arena can administrate multiple heaps.  New arena is created with an initial heap each time a thread calls malloc for 1st time. limited based on available cores.
    
    Main thread uses Main Arena.  
    
  if we set up another 0x20 fastbin by calling: b = malloc(1) and free(b)
  
  fastbin for 0x20 now looks like this:
    0x20: <addr_of_b> -> <addr_of_a> <- 0x0
  and the main arena now contains the addr of b in the 0x20 fastbin head location (previously addr of a before addr of b became fastbin 0x20 head)
  
  An important detail here is that if the requested allocation is within a fastbin size range, malloc searches fastbins first before allocating from top chunk.

  Writing somewhere in memory via fastbin dup:
    works on glibc <= 2.31
    
    double free to create a duplicate fastbin can be done when the free'd chunk is not the head of the fastbin linked list. 
    
    NOTE**  in gdb if a process hits SIGABRT, it's a good indicator you've triggered a glibc heap exploit mitigation. 
    
    switch to the needed frame, and use "context code" to view where the error is (pwndbg)
    The check only checks to make sure the top free'd chunk is not duplicated so we can put a different free'd chunk at the head and double free to get a fastbin dup
    
    malloc(chunk_A)
    malloc(chunk_B)
    
    free(chunk_A)
    free(chunk_B)
    
    free(chunk_A)
    
    this makes fastbin list become
    
    chunk_A_addr -> chunk_B_addr <- chunk_A_addr making a circular list and a duplicated chunk.
    
    so we can allocate a new chunk of that size which we would be given chunk_A and we can control the data in chunk_A so the first qword will be the fastbin forward pointer.  linking a chunk at the specified location in to the fastbins list. 
    
    Then request 3 chunks of the same size.  1st will be chunk_B, 2nd will be chunk_A, 3rd will be whatever the target chunk specified from the forward pointer is.  There is a size check here that would prevent any mismatch on size field.  (just an example to explain fastbin dup in a general way). If the size field is correct, then you will have an allocated memory at your target address and can write there.
