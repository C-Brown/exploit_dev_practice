We create the double free fastbin dup by allocating 2 chunks, calling free on both, then calling free again on the first chunk to create a duplicate (because the first chunk is no longer the head of the linked list).

One way to achieve code execution is to write to an address that point our code to a new address, __free_hook or __malloc_hook. 

We allocate the malloc of our first fastbin and write our target address into the fastbin's forward pointer (the first qword), which would be the address of our __malloc_hook - 16.
It's minus 16 bytes because malloc treats chunks as starting at 16 bytes before the user data.  that way 1st qword of our user data overlaps the hook.  

We malloc two chunks (chunk_b, then chunk_a), then we malloc 1 more to write to the address of our target forward pointer (malloc_hook) and we can overwrite it with the address to system.. so malloc_hook now points to system.

At this point the fake chunk needs to pass the size field check.. The way to solve this is to search for offsets in the malloc_hook that may form a valid fake chunk.  pwndbg: find_fake_fast &__malloc_hook

Change the forward pointer address to the target offset that creates a valid fake chunk, the offset would be the address of the hook minus however many bytes until the beginning of the valid fake chunk.
All chunks have to then match whatever size matches the fake chunk's size field. 

